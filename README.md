# The React Dropzone component with files list sorting support through drag and dropping

## Supported features:
1) Built with Vite, TypeScript, [React Dropzone](https://react-dropzone.js.org/) and TailwindCSS;
2) Ready to be built as a **reusable component** with full typing support;
3) Dropping single or multiple files (configurable);
4) Configurable accepted MIME types (For simplicity, I am not checking MIME type when manually inputting a source URL. Although it's possible by checking magic numbers inside a binary [like this](https://gist.github.com/topalex/ad13f76150e0b36de3c4a3d5ba8dc63a));
5) An example app provided in a separate folder. Good for testing;
6) Fully modularized CSS using prefixed TailwindCSS layers Vite's CSS modules. It guarantees that your project's global stylesheet won't be polluted;

## Usage
1) Clone and build the project using `npm run build`
2) Install it in your project by adding a reference to the local folder (`react-drag-n-drop: file://.../foo/bar/react-drag-n-drop`)
### Or
Just run `npm run dev` to run the example app

3) Make sure `<DragNDropProvider>` is put at the top
4) Import the component and start using as shown in the `src/example/App.tsx`

## Building
Run `npm run dev` to start developing

`npm run build` builds the library, ready to imported straight into your project

`npm run lint` lints the project (both library and example apps)

`npm run build-example` is an optional script for building the example app

## Design choices and key challenges
The idea was to create a simple component library that supported both file dropping and list sorting.

As of writing this (May, 2025) tools like React 19 and TailwindCSS 4 are newly released. Their GitHub repository pages are full of issues, and packages are not well optimized for them.

This urged me to rely on 3rd party packages as little as possible. Currently React Dropzone is the only significantly dependency. Rest of the code is generated by yours truly, except for a few places as noted in code comments. **No LLM was used** neither for *development*, nor for *research* purposes.

The crucial decision was to use the web browsers native [HTML Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API). It's performance is unparalleled and offers zero-dependency development. To my excitement, it also appeared better than expected.

But with that came the need of writing the sorting algorithm by myself, basically emulating what [Array slice method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) does. Please, keep in mind that `sortIndex` **is not zero-based**, nor it has to be positive. Try to think of it as a similar concept to `z-index`, where files with higher `sortIndex` appear further on the right.

Another challenge was configuring Vite and TailwindCSS to allow coexistence of both library and example apps with correct build pipelines. That meant fine-tuning almost every config file in the light of very poor official documentations (as expected from the React ecosystem), finding my own solutions by spending countless hours reading and participating in GitHub discussions.

For example, I created separated config files for main and test projects, binding them to scripts via options.

TailwindCSS content from `theme` and `utilities` layers are prefixed to avoid naming conflicts and resetting the `body` stylesheet. For additional security measures they are defined inside the main component wrapper class.

Also, CSS is automatically injected using [the appropriate Vite plugin](https://github.com/emosheeep/vite-plugin-lib-inject-css). So that users won't have to manually import them along the component.

D.ts files are automatically generated too in [vite-plugin-dts](https://www.npmjs.com/package/vite-plugin-dts) as per Vite recommendation.

Code structure is relatively straightforward. Components live in `components` folder in their respective folders or files (depending if they contain CSS modules), with helpers, contexts and hooks grouped accordingly as well.

The state is managed using the OG `useReducer` and `Context` combination. Although, at the expense of having to declare `<DragNDropProvider>` at the top of your components (if you want to programatically access data).

There's an interesting `useImage` hook which acts as an image source checker. It solves the problem of not knowing if a file or it's URL is a previewable image by relying on `<img>` events like `onerror`. Of course similar effect could be achieved by depending on heuristics to guess file validity by its extension, or fetching. This one's just seemed the most robust and declarative to me.
